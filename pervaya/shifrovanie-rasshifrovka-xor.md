---
order: 1
title: Шифрование/Расшифровка XOR
---

Модуль позволяет шифровать и расшифровывать как двоичные данные, так и произвольные строки.

#### Оглавление:

-  [Как подключить модуль](./shifrovanie-rasshifrovka-xor#как-подключить-модуль)

-  [Как зашифровать строку](./shifrovanie-rasshifrovka-xor#как-зашифровать-строку)

-  [Как расшифровать строку](./shifrovanie-rasshifrovka-xor#как-расшифровать-строку)

## Как подключить модуль

1. Добавить в общие макеты (или макеты объекта) файл: [ХЛ\_XOR](./ХЛ_XOR)

2. Создайте общий модуль и задайте ему название (например ХЛ\_ЛБ\_Шифрование\_Расшифровка). Общий модуль должен иметь атрибуты: Сервер, Вызов сервера

3. Добавьте в него следующий код:

   ```1c
   Функция XOR() Экспорт
   
   	ДанныеXOR	= ПолучитьОбщийМакет("ХЛ_ЛБ_XOR");
   	XOR			= Новый Массив(256);
   	ЧтениеXOR	= Новый ЧтениеДанных(ДанныеXOR);
   	
   	Для Индекс = 0 по 255 Цикл
   		XOR[Индекс] = ЧтениеXOR.ПрочитатьВБуферДвоичныхДанных(256);
   	КонецЦикла;
   	
   	ЧтениеXOR.Закрыть();	
   	
   	Возврат XOR;
   	
   КонецФункции // XOR()
   
   Функция СтрокаВДД(ЧислоПовторов = 1, Текст = "0123456789ABCDE ")  Экспорт
   	
   	Поток			= Новый ПотокВПамяти();
   	ЗаписьДанных	= Новый ЗаписьДанных(Поток);
   	
   	Для Индекс = 1 по ЧислоПовторов Цикл
   		ЗаписьДанных.ЗаписатьСимволы(Текст);
   	КонецЦикла;
   	
   	ЗаписьДанных.Закрыть();
   	Возврат Поток.ЗакрытьИПолучитьДвоичныеДанные();
   КонецФункции
   
   Функция ПолучитьКлюч256(Пароль) Экспорт
   	
   	//Если ЭтаФорма.ИспользоватьХэшПароля Тогда
   	//	Хеш = Новый ХешированиеДанных(ХешФункция.SHA256);
   	//	Хеш.Добавить(Пароль);
   	//	Возврат Хеш.ХешСумма;
   	//Иначе
   		Поток			= Новый ПотокВПамяти();
   		ЗаписьДанных	= Новый ЗаписьДанных(Поток);
   		
   		ДлинаТекста = СтрДлина(Пароль);
   		Если ДлинаТекста < 32 Тогда
   			ЗаписьДанных.ЗаписатьСимволы(Пароль);
   			Для НомерБайта = ДлинаТекста + 1 по 32 Цикл
   				ЗаписьДанных.ЗаписатьБайт(0);
   			КонецЦикла;
   		Иначе
   			ЗаписьДанных.ЗаписатьСимволы(Лев(Пароль, 32));
   		КонецЕсли;
   		
   		ЗаписьДанных.Закрыть();
   		Возврат Поток.ЗакрытьИПолучитьДвоичныеДанные();
   	//КонецЕсли;
   		
   КонецФункции
   // Функция - Зашифровать
   //
   // Параметры:
   //  Данные	 - ДвоичныеДанные	 - Шифруемые данные
   //  Ключ	 - ДвоичныеДанные	 - Закрытый пароль, ключ. Допустимы следующие длины ключа: 128, 192, 256 бит. 
   // 
   // Возвращаемое значение:
   //  ДвоичныеДанные - Зашифрованное сообщение
   //
   Функция Зашифровать(Данные, Ключ, РазмерКлюча = 256, БайтЗаполнитель = 0) Экспорт
   
   	XOR = XOR();
   	ЧтениеКлюча		= Новый ЧтениеДанных(Ключ);
   	БуферКлюча		= ЧтениеКлюча.ПрочитатьВБуферДвоичныхДанных();
   	РазмерКлючаФакт	= Ключ.Размер() * 8;
   	
   	Если РазмерКлючаФакт < РазмерКлюча Тогда
   		ВызватьИсключение "Данные ключа короче, чем заявленный размер!";
   	КонецЕсли;
   	
   	Const			= AES_init_contstants(РазмерКлюча);
   	RoundKey		= Новый Массив(Const.keyExpSize);
   	
   	AES_init_ctx(Const, RoundKey, БуферКлюча, XOR);
   	
   	ЧтениеКлюча.Закрыть();
   	ЧтениеДанных	= Новый ЧтениеДанных(Данные);
   	Поток			= Новый ПотокВПамяти();
   	ЗаписьДанных	= Новый ЗаписьДанных(Поток);
   	
   	РазмерДанных	= Данные.Размер();
   	РазмерБлока		= 16;
   	ЧислоБлоков		= Цел(РазмерДанных / РазмерБлока) + ?((РазмерДанных % РазмерБлока) > 0, 1, 0);
   	
   	Для НомерБлока = 1 по ЧислоБлоков Цикл
   		БуферДанных = Новый БуферДвоичныхДанных(РазмерБлока);
   		Если НомерБлока = ЧислоБлоков Тогда
   			РазмерХвоста = РазмерДанных - РазмерБлока*(ЧислоБлоков-1);
   			ЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(БуферДанных, 0, РазмерХвоста);
   			ЗаполнитьБайтами(БуферДанных, РазмерХвоста, 16 - РазмерХвоста, БайтЗаполнитель);
   		Иначе
   			ЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(БуферДанных, 0, РазмерБлока);
   		КонецЕсли;
   		
   		AES_ECB_encrypt(ЗаписьДанных, Const, RoundKey, БуферДанных, XOR);
   	КонецЦикла;
   	
   	ЧтениеДанных.Закрыть();
   	ЗаписьДанных.Закрыть();
   	
   	Возврат Поток.ЗакрытьИПолучитьДвоичныеДанные();
   	
   КонецФункции
   
   Процедура ЗаполнитьБайтами(БуфферДанных, ПозицияНачала, Размер, ЗначениеЗаполнителя)
   	
   	Для Позиция = ПозицияНачала по ПозицияНачала + Размер - 1 Цикл
   		БуфферДанных[Позиция] = ЗначениеЗаполнителя;
   	КонецЦикла;
   	
   КонецПроцедуры // ЗаполнитьБайтами
   
   // Функция - Расшифровать
   //
   // Параметры:
   //  Данные	 - ДвоичныеДанные	 - Зашифрованные данные данные. Длина должна быть кратна размеру блока = 16 байт
   //  Ключ	 - ДвоичныеДанные	 - Закрытый пароль, ключ. Допустимы следующие длины ключа: 128, 192, 256 бит. 
   // 
   // Возвращаемое значение:
   //  ДвоичныеДанные - Расшифрованное сообщение
   //
   Функция Расшифровать(Данные, Ключ, РазмерКлюча = 256) Экспорт
   	XOR = XOR();
   	ЧтениеКлюча		= Новый ЧтениеДанных(Ключ);
   	БуферКлюча		= ЧтениеКлюча.ПрочитатьВБуферДвоичныхДанных();
   	РазмерКлючаФакт	= Ключ.Размер() * 8;
   	
   	Если РазмерКлючаФакт < РазмерКлюча Тогда
   		ВызватьИсключение "Данные ключа короче, чем заявленный размер!";
   	КонецЕсли;
   	
   	Const			= AES_init_contstants(РазмерКлюча);
   	
   	Const			= AES_init_contstants(РазмерКлюча);
   	RoundKey		= Новый Массив(Const.keyExpSize);
   	
   	AES_init_ctx(Const, RoundKey, БуферКлюча, XOR);
   	
   	ЧтениеКлюча.Закрыть();
   	ЧтениеДанных	= Новый ЧтениеДанных(Данные);
   	Поток			= Новый ПотокВПамяти();
   	ЗаписьДанных	= Новый ЗаписьДанных(Поток);
   	
   	РазмерДанных	= Данные.Размер();
   	РазмерБлока		= 16;
   	Если (РазмерДанных % РазмерБлока) > 0 Тогда
   		ВызватьИсключение "Размер данных должен быть кратен размеру блока!";
   	КонецЕсли;
   	
   	ЧислоБлоков		= Цел(РазмерДанных / РазмерБлока);
   	
   	Для НомерБлока = 1 по ЧислоБлоков Цикл
   		БуферДанных = Новый БуферДвоичныхДанных(РазмерБлока);
   		ЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(БуферДанных, 0, ?(НомерБлока = ЧислоБлоков, РазмерДанных - РазмерБлока*(ЧислоБлоков-1), РазмерБлока));
   		AES_ECB_decrypt(ЗаписьДанных, Const, RoundKey, БуферДанных, XOR);
   	КонецЦикла;
   	
   	ЧтениеДанных.Закрыть();
   	ЗаписьДанных.Закрыть();
   	
   	Возврат Поток.ЗакрытьИПолучитьДвоичныеДанные();
   	
   КонецФункции
   
   Функция РасшифроватьДвоичныеДанныеСтроку(Данные) Экспорт
       Строка = "";
   	ЧтениеДанных = Новый ЧтениеДанных(Данные);
   	ИсходныйТекстСХвостом = ЧтениеДанных.ПрочитатьСимволы(); 
   	ПозицияХвоста = СтрНайти(ИсходныйТекстСХвостом, Символ(0));
   	Если ПозицияХвоста <> 0 Тогда
   		Строка = Лев(ИсходныйТекстСХвостом, ПозицияХвоста - 1);
   	Иначе
   		Строка = ИсходныйТекстСХвостом;
   	КонецЕсли;
   	
   	ЧтениеДанных.Закрыть();
   	Возврат Строка;
   КонецФункции // РасшифроватьСтроку()
   
   
   #Область ПроцедурыАлгоритмаAES
   
   Процедура AES_ECB_encrypt(ЗаписьДанных, Const, RoundKey, БуферДанных, XOR)
   	
   	state = init_state_t_v2(Const, БуферДанных);
   	
     	round = 0;
   
     	AddRoundKey(Const, 0, state, RoundKey, XOR);
   
     	round = 1; 
   	
   	Пока ИСТИНА Цикл
   				
   		SubBytes(Const, state);		
   		
     	  	ShiftRows(state);		
   				
   		Если (round = Const.Nr) Тогда
   			Прервать;
     	  	КонецЕсли;
   		
   		MixColumns(Const, state, XOR);		
   				
   		AddRoundKey(Const, round, state, RoundKey, XOR);		
   		
   		round = round + 1;
   		
   	КонецЦикла;
   	
       AddRoundKey(Const, Const.Nr, state, RoundKey, XOR);
   			
   	state_to_buf(ЗаписьДанных, state);
   	
   КонецПроцедуры
   
   Процедура AES_ECB_decrypt(ЗаписьДанных, Const, RoundKey, БуферДанных, XOR)
   	
   	state = init_state_t_v2(Const, БуферДанных);
   	round = 0;
   
     	AddRoundKey(Const, Const.Nr, state, RoundKey, XOR);
   
     	round = (Const.Nr - 1);
   	
   	Пока ИСТИНА Цикл
   	
     	  	InvShiftRows(state);
     	  	InvSubBytes(Const, state);
     	  	AddRoundKey(Const, round, state, RoundKey, XOR);
   		
   		Если (round = 0) Тогда
     	    	Прервать;
   		КонецЕсли;
   		
     	  	InvMixColumns(Const,state, XOR);
   		
   		round = round - 1;
   		
     	КонецЦикла;
   
   	state_to_buf(ЗаписьДанных, state);
   	
   КонецПроцедуры
   
   Функция AES_init_contstants(Key_size)
   	
   	Const = СтрокаJSONВЗначение(
   		"{
   		|	""Nk"":8
   		|	,""Nr"":14
   		|	,""sbox"":[99,124,119,123,242,107,111,197,48,1,103,43,254,215,171,118,202,130,201,125,250,89,71,240,173,212,162,175,156,164,114,192,183,253,147,38,54,63,247,204,52,165,229,241,113,216,49,21,4,199,35,195,24,150,5,154,7,18,128,226,235,39,178,117,9,131,44,26,27,110,90,160,82,59,214,179,41,227,47,132,83,209,0,237,32,252,177,91,106,203,190,57,74,76,88,207,208,239,170,251,67,77,51,133,69,249,2,127,80,60,159,168,81,163,64,143,146,157,56,245,188,182,218,33,16,255,243,210,205,12,19,236,95,151,68,23,196,167,126,61,100,93,25,115,96,129,79,220,34,42,144,136,70,238,184,20,222,94,11,219,224,50,58,10,73,6,36,92,194,211,172,98,145,149,228,121,231,200,55,109,141,213,78,169,108,86,244,234,101,122,174,8,186,120,37,46,28,166,180,198,232,221,116,31,75,189,139,138,112,62,181,102,72,3,246,14,97,53,87,185,134,193,29,158,225,248,152,17,105,217,142,148,155,30,135,233,206,85,40,223,140,161,137,13,191,230,66,104,65,153,45,15,176,84,187,22]
   		|	,""rsbox"":[82,9,106,213,48,54,165,56,191,64,163,158,129,243,215,251,124,227,57,130,155,47,255,135,52,142,67,68,196,222,233,203,84,123,148,50,166,194,35,61,238,76,149,11,66,250,195,78,8,46,161,102,40,217,36,178,118,91,162,73,109,139,209,37,114,248,246,100,134,104,152,22,212,164,92,204,93,101,182,146,108,112,72,80,253,237,185,218,94,21,70,87,167,141,157,132,144,216,171,0,140,188,211,10,247,228,88,5,184,179,69,6,208,44,30,143,202,63,15,2,193,175,189,3,1,19,138,107,58,145,17,65,79,103,220,234,151,242,207,206,240,180,230,115,150,172,116,34,231,173,53,133,226,249,55,232,28,117,223,110,71,241,26,113,29,41,197,137,111,183,98,14,170,24,190,27,252,86,62,75,198,210,121,32,154,219,192,254,120,205,90,244,31,221,168,51,136,7,199,49,177,18,16,89,39,128,236,95,96,81,127,169,25,181,74,13,45,229,122,159,147,201,156,239,160,224,59,77,174,42,245,176,200,235,187,60,131,83,153,97,23,43,4,126,186,119,214,38,225,105,20,99,85,33,12,125]
   		|	,""Rcon"":[141,1,2,4,8,16,32,64,128,27,54]
   		|	,""Multiply_14"":[0,14,28,18,56,54,36,42,112,126,108,98,72,70,84,90,224,238,252,242,216,214,196,202,144,158,140,130,168,166,180,186,219,213,199,201,227,237,255,241,171,165,183,185,147,157,143,129,59,53,39,41,3,13,31,17,75,69,87,89,115,125,111,97,173,163,177,191,149,155,137,135,221,211,193,207,229,235,249,247,77,67,81,95,117,123,105,103,61,51,33,47,5,11,25,23,118,120,106,100,78,64,82,92,6,8,26,20,62,48,34,44,150,152,138,132,174,160,178,188,230,232,250,244,222,208,194,204,65,79,93,83,121,119,101,107,49,63,45,35,9,7,21,27,161,175,189,179,153,151,133,139,209,223,205,195,233,231,245,251,154,148,134,136,162,172,190,176,234,228,246,248,210,220,206,192,122,116,102,104,66,76,94,80,10,4,22,24,50,60,46,32,236,226,240,254,212,218,200,198,156,146,128,142,164,170,184,182,12,2,16,30,52,58,40,38,124,114,96,110,68,74,88,86,55,57,43,37,15,1,19,29,71,73,91,85,127,113,99,109,215,217,203,197,239,225,243,253,167,169,187,181,159,145,131,141]
   		|	,""Multiply_11"":[0,11,22,29,44,39,58,49,88,83,78,69,116,127,98,105,176,187,166,173,156,151,138,129,232,227,254,245,196,207,210,217,123,112,109,102,87,92,65,74,35,40,53,62,15,4,25,18,203,192,221,214,231,236,241,250,147,152,133,142,191,180,169,162,246,253,224,235,218,209,204,199,174,165,184,179,130,137,148,159,70,77,80,91,106,97,124,119,30,21,8,3,50,57,36,47,141,134,155,144,161,170,183,188,213,222,195,200,249,242,239,228,61,54,43,32,17,26,7,12,101,110,115,120,73,66,95,84,247,252,225,234,219,208,205,198,175,164,185,178,131,136,149,158,71,76,81,90,107,96,125,118,31,20,9,2,51,56,37,46,140,135,154,145,160,171,182,189,212,223,194,201,248,243,238,229,60,55,42,33,16,27,6,13,100,111,114,121,72,67,94,85,1,10,23,28,45,38,59,48,89,82,79,68,117,126,99,104,177,186,167,172,157,150,139,128,233,226,255,244,197,206,211,216,122,113,108,103,86,93,64,75,34,41,52,63,14,5,24,19,202,193,220,215,230,237,240,251,146,153,132,143,190,181,168,163]
   		|	,""Multiply_13"":[0,13,26,23,52,57,46,35,104,101,114,127,92,81,70,75,208,221,202,199,228,233,254,243,184,181,162,175,140,129,150,155,187,182,161,172,143,130,149,152,211,222,201,196,231,234,253,240,107,102,113,124,95,82,69,72,3,14,25,20,55,58,45,32,109,96,119,122,89,84,67,78,5,8,31,18,49,60,43,38,189,176,167,170,137,132,147,158,213,216,207,194,225,236,251,246,214,219,204,193,226,239,248,245,190,179,164,169,138,135,144,157,6,11,28,17,50,63,40,37,110,99,116,121,90,87,64,77,218,215,192,205,238,227,244,249,178,191,168,165,134,139,156,145,10,7,16,29,62,51,36,41,98,111,120,117,86,91,76,65,97,108,123,118,85,88,79,66,9,4,19,30,61,48,39,42,177,188,171,166,133,136,159,146,217,212,195,206,237,224,247,250,183,186,173,160,131,142,153,148,223,210,197,200,235,230,241,252,103,106,125,112,83,94,73,68,15,2,21,24,59,54,33,44,12,1,22,27,56,53,34,47,100,105,126,115,80,93,74,71,220,209,198,203,232,229,242,255,180,185,174,163,128,141,154,151]
   		|	,""Multiply_9"":[0,9,18,27,36,45,54,63,72,65,90,83,108,101,126,119,144,153,130,139,180,189,166,175,216,209,202,195,252,245,238,231,59,50,41,32,31,22,13,4,115,122,97,104,87,94,69,76,171,162,185,176,143,134,157,148,227,234,241,248,199,206,213,220,118,127,100,109,82,91,64,73,62,55,44,37,26,19,8,1,230,239,244,253,194,203,208,217,174,167,188,181,138,131,152,145,77,68,95,86,105,96,123,114,5,12,23,30,33,40,51,58,221,212,207,198,249,240,235,226,149,156,135,142,177,184,163,170,236,229,254,247,200,193,218,211,164,173,182,191,128,137,146,155,124,117,110,103,88,81,74,67,52,61,38,47,16,25,2,11,215,222,197,204,243,250,225,232,159,150,141,132,187,178,169,160,71,78,85,92,99,106,113,120,15,6,29,20,43,34,57,48,154,147,136,129,190,183,172,165,210,219,192,201,246,255,228,237,10,3,24,17,46,39,60,53,66,75,80,89,102,111,116,125,161,168,179,186,133,140,151,158,233,224,251,242,205,196,223,214,49,56,35,42,21,28,7,14,121,112,107,98,93,84,79,70]
   		|	,""xtime"":[0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,27,25,31,29,19,17,23,21,11,9,15,13,3,1,7,5,59,57,63,61,51,49,55,53,43,41,47,45,35,33,39,37,91,89,95,93,83,81,87,85,75,73,79,77,67,65,71,69,123,121,127,125,115,113,119,117,107,105,111,109,99,97,103,101,155,153,159,157,147,145,151,149,139,137,143,141,131,129,135,133,187,185,191,189,179,177,183,181,171,169,175,173,163,161,167,165,219,217,223,221,211,209,215,213,203,201,207,205,195,193,199,197,251,249,255,253,243,241,247,245,235,233,239,237,227,225,231,229]
   		|	,""keyExpSize"":240
   		|	,""AES256"":false
   		|}"
   	);
   	
   	Если Key_size = 256 Тогда
   		Const.AES256 = Истина;
   	ИначеЕсли Key_size = 192 Тогда
   		Const.Nk = 6;
   		Const.Nr = 12;
   		Const.keyExpSize = 208
   	ИначеЕсли Key_size = 128 Тогда
   		Const.Nk = 4;
   		Const.Nr = 10;
   		Const.keyExpSize = 176;
   	Иначе
   		ВызватьИсключение "Неверное значение Key_size!";
   	КонецЕсли;
   	
   	Возврат Const;
   	
   КонецФункции
   
   Процедура AES_init_ctx(Const, RoundKey, Key, XOR)
   		
   	Перем i, j, k;
   	
   	i = 0;
   	j = 0;
   	k = 0;
   	
   	tempa = Новый Массив(4);
   	
   	Пока i < Const.Nk Цикл
   						
   		RoundKey[(i * 4) + 0] = Key[(i * 4) + 0];
   	    RoundKey[(i * 4) + 1] = Key[(i * 4) + 1];
   	    RoundKey[(i * 4) + 2] = Key[(i * 4) + 2];
   	    RoundKey[(i * 4) + 3] = Key[(i * 4) + 3];
   		
   		i = i + 1;
   		
   	КонецЦикла;
   	
   	i = Const.Nk;
   	
   	Пока i < 4 * (Const.Nr + 1) Цикл
   				
         	k = (i - 1) * 4;
   		
         	tempa[0] = RoundKey[k + 0];
         	tempa[1] = RoundKey[k + 1];
         	tempa[2] = RoundKey[k + 2];
         	tempa[3] = RoundKey[k + 3];
   		
   	    Если (i % Const.Nk = 0) Тогда
   	    
   			u8tmp 		= tempa[0];
   	        tempa[0] 	= tempa[1];
   	        tempa[1] 	= tempa[2];
   	        tempa[2] 	= tempa[3];
   	        tempa[3] 	= u8tmp;
   	     
   	      	tempa[0] = Const.sbox[ tempa[0] ];
   	        tempa[1] = Const.sbox[ tempa[1] ];
   	        tempa[2] = Const.sbox[ tempa[2] ];
   	        tempa[3] = Const.sbox[ tempa[3] ];
   	      	
   	      	tempa[0] = XOR[ tempa[0] ][ Const.Rcon[i/Const.Nk] ];
   			
   		КонецЕсли;
   	  
   		Если Const.AES256 Тогда
   			
   			Если (i % Const.Nk = 4) Тогда
   				
   				tempa[0] = Const.sbox[ tempa[0] ];
   		        tempa[1] = Const.sbox[ tempa[1] ];
   		        tempa[2] = Const.sbox[ tempa[2] ];
   		        tempa[3] = Const.sbox[ tempa[3] ];
   		      
   		    КонецЕсли;
   			
   		КонецЕсли;
   			
   	    j = i * 4; 
   		k = (i - Const.Nk) * 4;
   		
   	    RoundKey[j + 0] = XOR[RoundKey[k + 0]][ tempa[0] ];
   	    RoundKey[j + 1] = XOR[RoundKey[k + 1]][ tempa[1] ];
   	    RoundKey[j + 2] = XOR[RoundKey[k + 2]][ tempa[2] ];
   	    RoundKey[j + 3] = XOR[RoundKey[k + 3]][ tempa[3] ];
   		
   		i = i + 1;
   		
   	КонецЦикла;
   		
   КонецПроцедуры
   
   Функция init_state_t_v2(Const, БуферДанных)
   		
       Размерность = 4;
    
       state_t = Новый Массив(Размерность);
    
       Для НомерЭлементаВМассиве = 1 ПО Размерность Цикл		
       	state_t[НомерЭлементаВМассиве - 1] = Новый Массив(Размерность);		
       КонецЦикла;
       
       Для r = 0 По (Размерность - 1) Цикл
       	
       	Для c = 0 По 3 Цикл
   			
   			state_t[r][c] = БуферДанных[r*4+c];    		
       	
       	КонецЦикла;
       	
   	КонецЦикла;
   		
       Возврат state_t;
   	
   КонецФункции
   
   Процедура state_to_buf(ЗаписьДанных, state)
   	
   	Для Каждого МассивЧиселDec Из state Цикл
   		
   		Для Каждого ЧислоDec ИЗ МассивЧиселDec Цикл
   			ЗаписьДанных.ЗаписатьБайт(ЧислоDec);
   		КонецЦикла;
   		
   	КонецЦикла;
   	
   КонецПроцедуры
   
   Процедура AddRoundKey(Const, round, state, RoundKey, XOR)
   	
   	i = 0;
   		
   	Пока i < 4 Цикл
   		
   		k = (round * 16) + (i * 4); 
   		
   		state[i][0] = XOR[ state[i][0] ][ RoundKey[k + 0] ];
   		state[i][1] = XOR[ state[i][1] ][ RoundKey[k + 1] ];
   		state[i][2] = XOR[ state[i][2] ][ RoundKey[k + 2] ];
   		state[i][3] = XOR[ state[i][3] ][ RoundKey[k + 3] ];
   		
   		i = i + 1;
   		
   	КонецЦикла;
   		
   КонецПроцедуры
   
   Процедура SubBytes(Const, state)
   
   	Перем i;
     
     	i = 0;
     	  
   	Пока i < 4 Цикл
   		
   		state[0][i] = Const.sbox[ state[0][i] ];
   		state[1][i] = Const.sbox[ state[1][i] ];
   		state[2][i] = Const.sbox[ state[2][i] ];
   		state[3][i] = Const.sbox[ state[3][i] ];
   		
   		i = i + 1;
   		
   	КонецЦикла;
     
   КонецПроцедуры
   
   Процедура ShiftRows(state)
   	
   	Перем temp;
   	
   	temp = 0;
   	
   	// Rotate first row 1 columns to left  
     	temp        = state[0][1];
     	state[0][1] = state[1][1];
     	state[1][1] = state[2][1];
     	state[2][1] = state[3][1];
     	state[3][1] = temp;
   
   	// Rotate second row 2 columns to left  
   	temp        = state[0][2];
   	state[0][2] = state[2][2];
   	state[2][2] = temp;
   
   	temp        = state[1][2];
   	state[1][2] = state[3][2];
   	state[3][2] = temp;
   
   	// Rotate third row 3 columns to left
   	temp           = state[0][3];
   	state[0][3] = state[3][3];
   	state[3][3] = state[2][3];
   	state[2][3] = state[1][3];
   	state[1][3] = temp;
   	
   КонецПроцедуры
   
   Процедура MixColumns(Const, state, XOR)
   	
   	Перем i, Tmp, Tm, t;
   	
   	i 	= 0;
   	Tmp = 0;
   	Tm 	= 0;
   	t 	= 0;
   			
   	Пока i < 4 Цикл
   						
   		t	= state[i][0];
   		
   	    Tmp	= XOR[ XOR[ state[i][0] ][ state[i][1] ]][ XOR[ state[i][2] ][ state[i][3] ]];
   							
   		Tm	= XOR[ state[i][0] ][ state[i][1] ];
   		Tm	= Const.xtime[Tm];  
   		state[i][0] = XOR[ state[i][0] ][ XOR[Tm][Tmp] ];
   		
   	    Tm	= XOR[ state[i][1] ][ state[i][2] ];
   		Tm	= Const.xtime[Tm];
   		state[i][1] = XOR[ state[i][1] ][ XOR[Tm][Tmp] ];
   		
   	    Tm	= XOR[ state[i][2] ][ state[i][3] ];
   		Tm	= Const.xtime[Tm];
   		state[i][2] = XOR[ state[i][2] ][ XOR[Tm][Tmp] ];
   		
   	    Tm	= XOR[ state[i][3] ][ t ];
   		Tm	= Const.xtime[Tm];
   		state[i][3] = XOR[ state[i][3] ][ XOR[Tm][Tmp] ];
   		
   		i = i + 1;
   				
   	КонецЦикла;
   		
   КонецПроцедуры
   
   Процедура InvMixColumns(Const, state, XOR)
   
   	Перем i, a, b, c, d;
   	
   	i = 0;
   	a = 0;
   	b = 0;
   	c = 0;
   	d = 0;
   	
   	Пока i < 4 Цикл
   						
   		a = state[i][0];
   	    b = state[i][1];
   	    c = state[i][2];
   	    d = state[i][3];
   
   		state[i][0] = XOR[ XOR[ Const.Multiply_14[a] ][ Const.Multiply_11[b] ]][ XOR[ Const.Multiply_13[c] ][ Const.Multiply_9[d] ]];
   		state[i][1] = XOR[ XOR[ Const.Multiply_9[a]  ][ Const.Multiply_14[b] ]][ XOR[ Const.Multiply_11[c] ][ Const.Multiply_13[d] ]];
   		state[i][2] = XOR[ XOR[ Const.Multiply_13[a] ][ Const.Multiply_9[b]  ]][ XOR[ Const.Multiply_14[c] ][ Const.Multiply_11[d] ]];
   		state[i][3] = XOR[ XOR[ Const.Multiply_11[a] ][ Const.Multiply_13[b] ]][ XOR[ Const.Multiply_9[c]  ][ Const.Multiply_14[d] ]];
   												
   		i = i + 1;				
   							
   	КонецЦикла;
   	
   КонецПроцедуры
   
   Процедура InvSubBytes(ВнутренниеПеременные, state)
   
   	Перем i;
   	
   	i = 0;	
   	
   	Пока i < 4 Цикл
   		
   		state[0][i] = ВнутренниеПеременные.rsbox[ state[0][i] ];
   		state[1][i] = ВнутренниеПеременные.rsbox[ state[1][i] ];
   		state[2][i] = ВнутренниеПеременные.rsbox[ state[2][i] ];
   		state[3][i] = ВнутренниеПеременные.rsbox[ state[3][i] ];
   		
   		i = i + 1;
   		
   	КонецЦикла;  
   	  
   КонецПроцедуры
   
   Процедура InvShiftRows(state)
   
   	Перем temp;
   	
   	temp = 0;
   	  
   	// Rotate first row 1 columns to right  
   	temp = state[3][1];
   	state[3][1] = state[2][1];
   	state[2][1] = state[1][1];
   	state[1][1] = state[0][1];
   	state[0][1] = temp;
   
   	// Rotate second row 2 columns to right 
   	temp = state[0][2];
   	state[0][2] = state[2][2];
   	state[2][2] = temp;
   
   	temp = state[1][2];
   	state[1][2] = state[3][2];
   	state[3][2] = temp;
   
   	// Rotate third row 3 columns to right
   	temp = state[0][3];
   	state[0][3] = state[1][3];
   	state[1][3] = state[2][3];
   	state[2][3] = state[3][3];
   	state[3][3] = temp;
   	  
   КонецПроцедуры
   
   #КонецОбласти
   
   #Область СлужебныеПроцедурыИФунции
   
   Функция СтрокаJSONВЗначение(СтрокаJSON) Экспорт
   	
   	ЧтениеJSON = Новый ЧтениеJSON;
   	ЧтениеJSON.УстановитьСтроку(СтрокаJSON);
   	ЗначениеJSON = ПрочитатьJSON(ЧтениеJSON);	
   	ЧтениеJSON.Закрыть();
   	Возврат ЗначениеJSON;
   	
   КонецФункции
   
   #КонецОбласти
   ```

4. Примените изменения Обновив конфигурацию базы данных (F7)

## Как зашифровать строку

Придумайте Пароль в виде строки. С помощью него будет производиться шифрование файла. 

1. <note type="info">

   Рекомендуется формировать пароль из нескольких частей, где одна из частей не будет явно задана в передаваемых данных.

   </note>

**Ниже в примере рассмотрим следующий пример:**

Шлем файл json. Строку json мы шифруем полностью. Далее создаем новую json, где 3 поля: ИдентификаторСообщения, Дата, ТокенОрганизации  

```1c
//СтрокаData - Это строка, которую требуется шифровать
ДД = ХЛ_ЛБ_Шифрование_Расшифровка.СтрокаВДД(, СтрокаData);
		
Пароль = XMLСтрока(ИдентификаторСообщения) + XMLСтрока(Дата) + XMLСтрока(ТокенОрганизации) + "ng9<QGhE%kHK}v,hLtRjC*HV+]E?Wyp#7Z";
Ключ = ХЛ_ЛБ_Шифрование_Расшифровка.ПолучитьКлюч256(Пароль);
			
//Результат шифрования помещается в переменную СтрокаDataAES
СтрокаDataAES = ПолучитьHexСтрокуИзДвоичныхДанных(ХЛ_ЛБ_Шифрование_Расшифровка.Зашифровать(ДД, Ключ));  
```

## Как расшифровать строку

```1c
	Пароль = XMLСтрока(Структура.id_message) + XMLСтрока(Структура.date) + XMLСтрока(Структура.token) + "ng9<QGhE%kHK}v,hLtRjC*HV+]E?Wyp#7Z";
	Ключ = ХЛ_ЛБ_Шифрование_Расшифровка.ПолучитьКлюч256(Пароль);
			
	СтрокаDataHEX = ХЛ_ЛБ_Шифрование_Расшифровка.Расшифровать(ПолучитьДвоичныеДанныеИзHexСтроки(Структура.data), Ключ);
	
	//Результат расшифровки помещаем в переменную СтрокаData
	СтрокаData = ХЛ_ЛБ_Шифрование_Расшифровка.РасшифроватьДвоичныеДанныеСтроку(СтрокаDataHEX);
```


